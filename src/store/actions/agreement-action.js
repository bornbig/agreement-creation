import axios from 'axios';
import Moralis from "moralis";
import lighthouse from '@lighthouse-web3/sdk';
import { API_ENDPOINT, DEFAULT_NETWORK_STRING, LIGHTHOSE_API_KEY, MORALIS_API_KEY } from '../../config/config';
import Cookies from 'universal-cookie';


export async function storeDetails(details, delivery){
  const writtenAgreement = {
      details,
      delivery
  }

  const hash = await saveToIPFS(writtenAgreement);

  return hash;
}

export async function storeSkills(skills){
  const hash = await saveToIPFS(skills);

  return hash;
}


async function saveToIPFS(content){
  const abi = [
    {
        path: "metadata.json",
        content: content
    }
  ]

  if(!Moralis.Core.isStarted){
    await Moralis.start({
      apiKey: MORALIS_API_KEY,
      // ...and any other configuration
    });
  }

  const response = await Moralis.EvmApi.ipfs.uploadFolder({ abi });

  const jsonResponse = response.toJSON();

  const { path } = jsonResponse[0];

  const splitPath = path.split("/ipfs/");

  return splitPath[1];
}


export async function getDetails(ipfs_hash){
  const url = `https://ipfs.moralis.io:2053/ipfs/${ipfs_hash}`;

  const data = (await axios.get(url)).data

  if(data){
    return data;
  }

  return {}
}


const encryptionSignature = async(web3) =>{
  const address = await web3.eth.getAccounts();
  console.log(address[0]);
  const messageRequested = (await lighthouse.getAuthMessage(address[0])).data.message;
  console.log(messageRequested);
  const signedMessage = await web3.eth.personal.sign(messageRequested, address[0]);
  return({
    signedMessage: signedMessage,
    publicKey: address[0]
  });
}

export async function uploadDeliveres(e, web3, params, progressCallback){
  const sig = await encryptionSignature(web3);
  const response = await lighthouse.uploadEncrypted(
    e,
    LIGHTHOSE_API_KEY,
    sig.publicKey,
    sig.signedMessage,
    progressCallback
  );
  const cid = await response.data.Hash;
  const { escrow, agreement, agreementId } = params;
  const finalCid =  await applyAccessConditions(web3, cid, escrow, agreement, agreementId);

  return finalCid;
}

const applyAccessConditions = async(web3, cid, escrow, agreement, agreementId) =>{
  // CID on which you are applying encryption
  // CID is generated by uploading a file with encryption
  // Only the owner of the file can apply access conditions
  

  // Conditions to add
  const conditions = [
    {
      id: 1,
      chain: "Mumbai",
      method: "hasAccessToDelivery",
      standardContractType: "Custom",
      contractAddress: escrow,
      returnValueTest: {
        comparator: "==",
        value: "true"
      },
      parameters: [agreement, agreementId, ":userAddress"],
      inputArrayType: ["address", "uint256","address"],
      outputType: "bool"
    },
  ];

  // Aggregator is what kind of operation to apply to access conditions
  // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
  const aggregator = "([1])";
  const {publicKey, signedMessage} = await encryptionSignature(web3);

  /*
    accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
      Parameters:
        publicKey: owners public key
        CID: CID of the file to decrypt
        signedMessage: message signed by the owner of publicKey
        conditions: should be in a format like above
        aggregator: aggregator to apply conditions
  */
  const response = await lighthouse.applyAccessCondition(
    publicKey,
    cid,
    signedMessage,
    conditions,
    aggregator
  );

  console.log(response);

  return response.data.cid;
  /*
    {
      data: {
        cid: "QmZkEMF5y5Pq3n291fG45oyrmX8bwRh319MYvj7V4W4tNh",
        status: "Success"
      }
    }
  */
}


export async function decryptDelivery (cid, web3){
  
  const {publicKey, signedMessage} = await encryptionSignature(web3);

  const keyObject = await lighthouse.fetchEncryptionKey(
    cid,
    publicKey,
    signedMessage
  );

  const fileType = "application/zip";
  const decrypted = await lighthouse.decryptFile(cid, keyObject.data.key, fileType);

  console.log(decrypted);

  const url = URL.createObjectURL(decrypted);

  return url;
}

export async function getAgreements(wallet){
  const url = `${API_ENDPOINT}/agreement/list?wallet_addresses=${wallet}&chain=${DEFAULT_NETWORK_STRING}`;
  const agreements = (await axios.get(url)).data;

  return agreements.nfts;
}


export async function createOfflineAgreement(chain, agreement, agreement_object){
  const url = `${API_ENDPOINT}/agreement/offline/create`;
  const cookies = new Cookies();
  const token = cookies.get('user_auth_token');
  const creation = (await axios.post(url, {chain, agreement, agreement_object},  {headers: {"Authorization": token}})).data;

  return creation._id;
}

export async function getOffchainAgreement(id){
  const url = `${API_ENDPOINT}/agreement/${id}`;
  const cookies = new Cookies();
  const token = cookies.get('user_auth_token');
  const agreementDetails = (await axios.get(url, {headers: {"Authorization": token}})).data;

  return agreementDetails;
}

export async function getAgreementEmails(chain, agreement, id){
  const url = `${API_ENDPOINT}/agreement/${parseInt(chain)}/${agreement}/${id}`;
  const cookies = new Cookies();
  const token = cookies.get('user_auth_token');
  const agreementEmails = (await axios.get(url, {headers: {"Authorization": token}})).data;

  return agreementEmails;
}