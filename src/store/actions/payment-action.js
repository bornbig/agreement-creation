import axios from 'axios';
import Moralis from "moralis";
import lighthouse from '@lighthouse-web3/sdk';
import { LIGHTHOSE_API_KEY, MORALIS_API_KEY } from '../../config/config';
import apiRequest from '../../config/api-request';


export async function saveToIPFS(content){
  const request = apiRequest.utility.uploadToIPFS(content);
  const response = (await axios(request)).data;

  return response.data.ipfashHash;
}


export async function getIPFSContent(ipfsHash){
  const request = apiRequest.utility.getIPFSContent(ipfsHash);
  const response = (await axios(request)).data;

  return response.data.content;
}


const encryptionSignature = async(web3) =>{
  const address = await web3.eth.getAccounts();
  console.log(address[0]);
  const messageRequested = (await lighthouse.getAuthMessage(address[0])).data.message;
  console.log(messageRequested);
  const signedMessage = await web3.eth.personal.sign(messageRequested, address[0]);
  return({
    signedMessage: signedMessage,
    publicKey: address[0]
  });
}

export async function uploadDeliveres(e, web3, params, progressCallback){
  const sig = await encryptionSignature(web3);
  const response = await lighthouse.uploadEncrypted(
    e,
    LIGHTHOSE_API_KEY,
    sig.publicKey,
    sig.signedMessage,
    progressCallback
  );
  const cid = await response.data.Hash;
  const { escrow, agreement, agreementId } = params;
  const finalCid =  await applyAccessConditions(web3, cid, escrow, agreement, agreementId);

  return finalCid;
}

const applyAccessConditions = async(web3, cid, escrow, agreement, agreementId) =>{
  // CID on which you are applying encryption
  // CID is generated by uploading a file with encryption
  // Only the owner of the file can apply access conditions
  

  // Conditions to add
  const conditions = [
    {
      id: 1,
      chain: "polygon",
      method: "hasAccessToDelivery",
      standardContractType: "Custom",
      contractAddress: escrow,
      returnValueTest: {
        comparator: "==",
        value: "true"
      },
      parameters: [agreement, agreementId, ":userAddress"],
      inputArrayType: ["address", "uint256","address"],
      outputType: "bool"
    },
  ];

  // Aggregator is what kind of operation to apply to access conditions
  // Suppose there are two conditions then you can apply ([1] and [2]), ([1] or [2]), !([1] and [2]).
  const aggregator = "([1])";
  const {publicKey, signedMessage} = await encryptionSignature(web3);

  /*
    accessCondition(publicKey, cid, signedMessage, conditions, aggregator)
      Parameters:
        publicKey: owners public key
        CID: CID of the file to decrypt
        signedMessage: message signed by the owner of publicKey
        conditions: should be in a format like above
        aggregator: aggregator to apply conditions
  */
  const response = await lighthouse.applyAccessCondition(
    publicKey,
    cid,
    signedMessage,
    conditions,
    aggregator
  );

  console.log(response);

  return response.data.cid;
  /*
    {
      data: {
        cid: "QmZkEMF5y5Pq3n291fG45oyrmX8bwRh319MYvj7V4W4tNh",
        status: "Success"
      }
    }
  */
}


export async function decryptDelivery (cid, web3){
  
  const {publicKey, signedMessage} = await encryptionSignature(web3);

  const keyObject = await lighthouse.fetchEncryptionKey(
    cid,
    publicKey,
    signedMessage
  );

  const fileType = "application/zip";
  const decrypted = await lighthouse.decryptFile(cid, keyObject.data.key, fileType);

  console.log(decrypted);

  const url = URL.createObjectURL(decrypted);

  return url;
}

export async function getPaymentList(user){
  const request = apiRequest.payment.list(user);
  const response = (await axios(request)).data;

  return response.data;
}


export async function createPayment(agreement_object){
  const request = apiRequest.payment.create(agreement_object);
  const response = (await axios(request)).data;

  return response.data;
}


export async function createOnchainPayment(agreement_object){
  const request = apiRequest.payment.createOnChain(agreement_object);
  const response = (await axios(request)).data;

  return response.data;
}

export async function deleteOffChainPayment(message, signature, paymentid){
  const request = apiRequest.payment.deleteOffChain(message, signature, paymentid);
  const response = (await axios(request)).data;

  return response.data;
}

export const UPDATE_AGREEMENT = "UPDATE_AGREEMENT";
export async function getPaymentById(id){
  const request = apiRequest.payment.getSingleById(id);
  const agreementDetails = (await axios(request)).data;

  return agreementDetails.data;
}

export async function getOnchainPayment(chain, agreement, id){
  const request = apiRequest.payment.getSingleOnChain(chain, agreement, id);
  const response = (await axios(request)).data;

  return response.data;
}